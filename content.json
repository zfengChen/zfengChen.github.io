{"meta":{"title":"mubai","subtitle":"mubaiのBlog","description":"博客因兴趣诞生,在不断完善中","author":"mubai","url":"https://zfengchen.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2021-12-22T13:02:50.000Z","updated":"2021-12-23T05:39:54.533Z","comments":false,"path":"about/index.html","permalink":"https://zfengchen.github.io/about/index.html","excerpt":"","text":"自律の快乐每天向前走一小步、就是对自我的超越 当你在学习时感到烦躁，说明你还需要 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在工作中不断获得了友谊和朋友时，说明你将取得工作上的 成功 。 关于博主 00后，二次元动漫、漫画、游戏爱好者。 对前端和后端都抱有很大的兴趣。 联系我B站：东方小慕白（萌新up） QQ邮箱：1029251038@qq.com 座右铭：我相信努力可以改变一切"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-12-22T10:12:22.355Z","comments":true,"path":"archives/index.html","permalink":"https://zfengchen.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://zfengchen.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://zfengchen.github.io/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://zfengchen.github.io/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://zfengchen.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://zfengchen.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-12-23T03:41:31.857Z","comments":false,"path":"List/movies/index.html","permalink":"https://zfengchen.github.io/List/movies/index.html","excerpt":"","text":"推荐的视频"},{"title":"相册","date":"2021-12-23T06:07:26.378Z","updated":"2021-12-23T06:07:26.378Z","comments":false,"path":"List/gallery/index.html","permalink":"https://zfengchen.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 background 一些好看的背景图"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-12-22T12:39:29.448Z","comments":false,"path":"List/music/index.html","permalink":"https://zfengchen.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-12-23T05:31:49.767Z","comments":false,"path":"List/gallery/bg1/index.html","permalink":"https://zfengchen.github.io/List/gallery/bg1/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://zfengchen.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"基于vue2的天气查询","slug":"25-基于vue2的天气查询","date":"2022-01-28T06:44:31.000Z","updated":"2022-01-28T07:44:15.514Z","comments":true,"path":"posts/25.html","link":"","permalink":"https://zfengchen.github.io/posts/25.html","excerpt":"","text":"前言 这个是项目是对基于vue的天气预报的重构 项目已上线，现在可以通过访问天气查询来使用该项目。 vue脚手架Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 实现的交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 实现功能输入城市名称就可以查询到未来5天的天气情况。","categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://zfengchen.github.io/tags/Ajax/"},{"name":"Axios","slug":"Axios","permalink":"https://zfengchen.github.io/tags/Axios/"},{"name":"Vant","slug":"Vant","permalink":"https://zfengchen.github.io/tags/Vant/"}]},{"title":"基于vue2的校园实时防疫监控","slug":"24-基于vue2的校园实时防疫监控","date":"2022-01-28T06:38:27.000Z","updated":"2022-01-28T07:43:40.474Z","comments":true,"path":"posts/24.html","link":"","permalink":"https://zfengchen.github.io/posts/24.html","excerpt":"","text":"前言项目已上线，现在可以通过访问基于vue的校园实时防疫监控来使用。 基于vue的校园实时防疫监控知识点 Vue基础知识 Axios网络请求 Echarts可视化 Swiper焦点轮播图 Vue-Router 封装组件 可使用地址用友：https://api.yonyoucloud.com/apilink/#/天行：https://www.tianapi.com/ 项目运行 安装依赖npm i 开发环境下运行npm run serve 或者生产环境下运行// 安装依赖 npm i -g serve // 项目打包 npm i build // 项目本地预览 serve -s dist 效果图 开发过程中的思维方式 在Vue框架中，是组件式开发，将组件分离的更加细致一点 关于组件实例化问题 拆分中组件之后，组件的多次调用，会每一次实例化一个独立的对象 未解决问题 跨域问题(主要由后端解决) 开发环境 开发环境下的跨域处理，只能在开发环境下运行，打包之后是不能运行的 proxy都是开发环境跨域 生产环境 cors(主) jsonp(次) 打包路径问题 publicPath指定具体子路径信息 publicPath: process.env.NODE_ENV === 'production' ? '/covid19' : '/'","categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://zfengchen.github.io/tags/Ajax/"},{"name":"Axios","slug":"Axios","permalink":"https://zfengchen.github.io/tags/Axios/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://zfengchen.github.io/tags/Vue-Router/"},{"name":"Echarts","slug":"Echarts","permalink":"https://zfengchen.github.io/tags/Echarts/"},{"name":"Swiper","slug":"Swiper","permalink":"https://zfengchen.github.io/tags/Swiper/"},{"name":"Vant","slug":"Vant","permalink":"https://zfengchen.github.io/tags/Vant/"}]},{"title":"Valine评论问题-国外版(置顶)","slug":"23-Valine评论问题","date":"2022-01-28T06:35:13.000Z","updated":"2022-01-28T07:16:41.054Z","comments":true,"path":"posts/23.html","link":"","permalink":"https://zfengchen.github.io/posts/23.html","excerpt":"","text":"前言 自从valine更新后，通用的请求域名已经失效，根据github社区的大佬们讨论，添加了serverUrls后，理论上应该可以重新访问。 但是通过postman测试，访问的域名还是以前旧的通用域名。 更加离谱的是在重新刷新网页后就可以向新的域名发起请求并能获取到数据。而且每一次进去到博客，都要重新刷新网页清理缓存才能向新的域名发起正确的请求。 所以请各位访客想评论的话，就只能刷新页面，才能正常地进行评论。leancloud国内版本和国外版本区别国外版不需要实名，国内版需要实名制，所以，大部分会选择国外版本。 问题我的博客是hexo+butterfly，评论系统用的是valine。然后leancloud更新后就不允许使用通用域名访问数据。 解决方法(别人的)CSDN上有位熊第就遇到和我一样的情况，他也给出了解决方法。【解决方法】Valine评论不显示 解决方法(自己的)我改用国内版，一切搞定…","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Valine","slug":"Valine","permalink":"https://zfengchen.github.io/tags/Valine/"},{"name":"Leancloud","slug":"Leancloud","permalink":"https://zfengchen.github.io/tags/Leancloud/"}]},{"title":"javascript里的this","slug":"22-javascript里的this","date":"2022-01-27T02:58:38.000Z","updated":"2022-01-27T03:59:54.182Z","comments":true,"path":"posts/22.html","link":"","permalink":"https://zfengchen.github.io/posts/22.html","excerpt":"","text":"前言 this有四种绑定方式，分别是：默认绑定（window）、隐式绑定、硬绑定（显示绑定）、构造函数绑定（new） this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 默认绑定（window）函数内不存在任何值，且在全局内调用函数 function girl(){ console.log(this) } girl() // 输出 window，这里相当于window.girl() 隐式绑定函数里面有值，指向函数内部的值 var girl = { name : 'zs' detail : function(){ console.log(this.name) } } girl.detail() // 输出 zs 硬绑定（显示绑定）在对象外部定义另一个含有相关属性值的对象，然后通过**call()、apply()、bind()**重定义对象里面的this的指向。最后使this指向新的指定对象（比如girl1、girl2） var girl = { name : 'zs' detail : function(){ console.log(this.name) } } var girl1 = { name:'ls'} var girl2 = { name:'ww'} // call apply bind 为显示绑定 girl.detail.call(girl1) // 输出 ls girl.detail.call(girl2) // 输出 ww 构造函数绑定function Lover() { this.name = name this.detail : function(){ console.log(this.name) } } var name = 'zs' var xH = new Lover('xh') xH.detail.() // 输出 ww 总结this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。 最后推荐看一下一位博主总结的this指向问题,以及b站蛋老师的视频追梦子-彻底理解js中this的指向，不必硬背。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"this","slug":"this","permalink":"https://zfengchen.github.io/tags/this/"},{"name":"面试高频题","slug":"面试高频题","permalink":"https://zfengchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"}]},{"title":"git远程仓库","slug":"21-git远程仓库","date":"2022-01-27T02:39:19.000Z","updated":"2022-01-27T02:54:24.430Z","comments":true,"path":"posts/21.html","link":"","permalink":"https://zfengchen.github.io/posts/21.html","excerpt":"","text":"前言Git远程仓库 Git 并不像 SVN 那样有个中心服务器。 目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 Git远程仓库 Git中存在两种类型的仓库，即本地仓库和远程仓库。 我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab（公司使用）等。 gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub 码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快 GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。 前提：必须有公钥若没有公钥，需要先生成公钥 生成SSH公钥ssh-keygen -t rsa 不断回车如果公钥已经存在，则自动覆盖Gitee设置账户共公钥 获取公钥cat ~/.ssh/id_rsa.pub 验证是否配置成功ssh -T git@gitee.com 1、 操作远程仓库1.1、添加远程仓库此操作是先初始化本地库，然后与已创建的远程库进行对接。 命令： git remote add &lt;远端名称（一般为origin）&gt; &lt;仓库路径（ssh地址）&gt; 远端名称，默认是origin，取决于远端服务器设置 仓库路径，从远端服务器获取此URL 例如: git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git 1.2、查看远程仓库命令：git remote 出现origin（远端名称）表示成功 1.3、推送到远程仓库命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名] ] 如果远程分支名和本地分支名称相同，则可以只写本地分支 git push origin master（使用情景：远程仓库为空） -f 表示强制覆盖（一般禁用，只允许添加，不允许覆盖） –set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。 git push –set-upstream origin master（使用情景：远程仓库不为空，用于绑定关系，建议第一次推送就加上） 如果当前分支已经和远端分支关联，则可以省略分支名和远端名。 git push 将 master 分支推送到已关联的远端分支。 1.4、 本地分支与远程分支的关联关系查看关联关系我们可以使用 git branch -vv 命令 1.5、从远程仓库克隆如果已经有一个远端仓库，我们可以直接clone到本地。 命令: git clone &lt;仓库路径&gt; [本地目录] 本地目录可以省略，会自动生成一个目录 1.6、从远程仓库中抓取和拉取远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。 抓取 命令：git fetch [remote name] [branch name] 抓取指令就是将仓库里的更新都抓取到本地，不会进行合并，后续还要自己进行（merge合并分支） 如果不指定远端名称和分支名，则抓取所有分支 拉取 命令：git pull [remote name] [branch name] 拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 如果不指定远端名称和分支名，则抓取所有并更新当前分支。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"https://zfengchen.github.io/tags/git/"}]},{"title":"git分支","slug":"20-git分支","date":"2022-01-27T02:29:59.000Z","updated":"2022-01-27T02:54:24.434Z","comments":true,"path":"posts/20.html","link":"","permalink":"https://zfengchen.github.io/posts/20.html","excerpt":"","text":"前言Git分支 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 Git远程仓库 Git 并不像 SVN 那样有个中心服务器。 目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 Git分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。 1、查看本地分支命令：git branch 2、创建本地分支命令：git branch 分支名 *3、切换分支(checkout)**命令：git checkout 分支名 我们还可以直接切换到一个不存在的分支（创建并切换） 命令：git checkout -b 分支名 4、合并分支(merge)一个分支上的提交可以合并到另一个分支 命令：git merge 分支名称 5、删除分支不能删除当前分支，只能删除其他分支 git branch -d b1 删除分支时，需要做各种检查 git branch -D b1 不做任何检查，强制删除 6、解决冲突当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解 决冲突，解决冲突步骤如下： (1) 处理文件中冲突的地方 (2) 将解决完冲突的文件加入暂存区(add) (3) 提交到仓库(commit) 冲突部分的内容处理如下所示：","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"https://zfengchen.github.io/tags/git/"}]},{"title":"git基础","slug":"19-git基础","date":"2022-01-27T02:05:48.000Z","updated":"2022-01-27T11:01:30.477Z","comments":true,"path":"posts/19.html","link":"","permalink":"https://zfengchen.github.io/posts/19.html","excerpt":"","text":"前言 Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 git基础配置备注： Git GUI：Git提供的图形界面工具 Git Bash：Git提供的命令行工具 打开Git Bash 设置用户信息 git config –global user.name “itcast” git config –global user.email “hello@itcast.cn” 查看配置信息 git config –global user.name git config –global user.email git基础操作指令Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git的命令而发生变化。 主要命令： 1. git add (工作区 –&gt; 暂存区) 2. git commit (暂存区 –&gt; 本地仓库) 3.1 查看修改的状态（status） 作用：查看的修改的状态（暂存区、工作区） 命令形式：git status 3.2 添加工作区到暂存区(add) 作用：添加工作区一个或多个文件的修改到暂存区 命令形式：git add 单个文件名/通配符 将所有修改加入暂存区：git add . 3.3 提交暂存区到本地仓库(commit) 作用：提交暂存区内容到本地仓库的当前分支 命令形式：git commit -m ‘注释内容’ 3.4 查看提交日志(log) 在 3.1 中配置的别名 **git-log 就包含了这些参数，所以后续可以直接使用指令 git-log** 作用:查看提交记录 命令形式：git log [option] options -all 显示所有分支 -pretty=oneline 将提交信息显示为一行 -abbrev-commit 使得输出的commitId更简短 -graph 以图的形式显示 3.5 版本回退 作用：版本切换 命令形式：git reset –hard commitID commitID 可以使用 git-log 或 git log 指令查看 如何查看已经删除的记录？ git reflflog 这个指令可以看到已经删除的提交记录","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"git","permalink":"https://zfengchen.github.io/tags/git/"}]},{"title":"node连接mysql","slug":"18-node连接mysql","date":"2022-01-27T02:03:01.000Z","updated":"2022-01-27T03:55:50.787Z","comments":true,"path":"posts/18.html","link":"","permalink":"https://zfengchen.github.io/posts/18.html","excerpt":"","text":"前提：安装插件express（4.17.1）和mysql（2.2.5），配置package.json（添加type属性）npm i express@4.17.1 mysql2@2.2.5 添加type属性，值为module。目的是支持es6语法 { \"type\": \"module\" } 创建db数据库操作模块（连接池） // db文件夹下index.js import mysql from 'mysql2' const pool = mysql.createPool({ host: '127.0.0.1', // 地址 port: '3306', database: '数据库名字', user: 'root', password:'123456' }) export default pool.promise() 创建并封装对数据库需要执行的方法(可以不封装，直接将代码写在路由模块里面) // contyller文件夹下user_ctrl.js import db from '../db/index.js' export async function getAllUser(req, res) { const [data] = await db.query('select * from user') res.send({ status: 0, message: 'success', data }) } 创建路由 // router文件夹下userRouter.js import express from 'express' import { getAllUser } from '../controller/user_ctrl.js' // 按需导入操作数据库的方法 const router = express.Router() router.get('/user', getAllUser) export default router 创建服务器 // app.js import express from 'express' import {userRouter} from './router/userRouter.js' const app = express() // 第一个参数是可选 app.use('/api',userRouter) app.listen('80', ()=&gt;{ console.log('running at http://127.0.0.1') })","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zfengchen.github.io/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://zfengchen.github.io/tags/mysql/"}]},{"title":"关系型数据库和非关系型数据库","slug":"17-关系型数据库和非关系型数据库","date":"2022-01-27T02:02:02.000Z","updated":"2022-01-27T02:57:04.132Z","comments":true,"path":"posts/17.html","link":"","permalink":"https://zfengchen.github.io/posts/17.html","excerpt":"","text":"一、关系型数据库关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。 优点： 易于维护：都是使用表结构，格式一致； 使用方便：SQL语言通用，可用于复杂查询； 复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。 缺点： 读写性能比较差，尤其是海量数据的高效率读写； 固定的表结构，灵活度稍欠； 高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。 二、非关系型数据库非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。 优点： 格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘； 高扩展性； 成本低：nosql数据库部署简单，基本都是开源软件。 缺点： 不提供sql支持，学习和使用成本较高； 无事务处理； 数据结构相对复杂，复杂查询方面稍欠。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://zfengchen.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"hexo相关指令","slug":"16-hexo相关指令","date":"2022-01-26T14:19:20.000Z","updated":"2022-01-26T14:49:58.524Z","comments":true,"path":"posts/16.html","link":"","permalink":"https://zfengchen.github.io/posts/16.html","excerpt":"","text":"时隔多日，我又来更新我的小博客咯~ 前言 前一阵子忙于学习和找工作，导致没有时间经营我的小博客，现在我又回来了。 过了一段时间，我发现我忘记了hexo的相关指令，于是决定在这里记录下来，并置顶，这样一来就不怕忘记咯~ Hexo常见指令&lt;!-- 新建一篇文章 --&gt; $ hexo new \"文章标题\" &lt;!-- 清理缓存 --&gt; $ hexo clean &lt;!-- 生成静态文件 --&gt; $ hexo g &lt;!-- 开启本地服务器，默认端口http://127.0.0.1:4000 --&gt; $ hexo s &lt;!-- 部署网站 --&gt; $ hexo d 以上这些就够用了，更多指令，可以去Hexo官方文档查看Hexo中文文档","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"博客","slug":"博客","permalink":"https://zfengchen.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"package.json分析","slug":"15-package-json分析","date":"2022-01-02T00:45:17.000Z","updated":"2022-01-02T01:15:21.335Z","comments":true,"path":"posts/15.html","link":"","permalink":"https://zfengchen.github.io/posts/15.html","excerpt":"","text":"package.json里常见的配置{ \"name\": \"webpack-text\", //版本 \"version\": \"1.0.0\", \"main\": \"index.js\", // 存储命令的别名 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\" }, \"keywords\": [], \"author\": \"\", // 项目遵循的协议 默认ISC协议（就是开发源代码的协议） \"license\": \"ISC\", //开发依赖 \"devDependencies\": { \"css-loader\": \"^6.5.1\", \"html-loader\": \"^3.0.1\", \"html-webpack-plugin\": \"^5.5.0\", \"style-loader\": \"^3.3.1\", \"ts-loader\": \"^9.2.6\", \"vue-loader\": \"^15.9.8\", \"vue-template-compiler\": \"^2.6.14\", \"webpack\": \"^5.64.1\", \"webpack-cli\": \"^4.9.1\", \"webpack-dev-server\": \"^4.5.0\" }, \"description\": \"\", //项目依赖 \"dependencies\": { \"jquery\": \"^3.6.0\" } } npm安装package.json中的模块依赖_致敬code大神的博客-CSDN博客 npm一键安装package.json里的所有依赖文件 npm install dependencies（核心依赖/运行依赖 基本上是第三方包） 只安装核心依赖项的指令 npm install --dependencies devDependencies（开发依赖） npm install --devDependencies","categories":[{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"MVVM和MVC","slug":"14-MVVM和MVC","date":"2022-01-02T00:44:08.000Z","updated":"2022-01-02T00:56:32.849Z","comments":true,"path":"posts/14.html","link":"","permalink":"https://zfengchen.github.io/posts/14.html","excerpt":"","text":"MVVM属于一种架构模式，核心思想是：数据驱动试图 好处是： 低耦合 可重用性高 独立开发 可测试性 详解MVVM M：业务数据模型和试图没关系 和java里面的service服务层一样 V：视图（view） VM：视图数据模型，视图数据 详解MVC M：业务数据模型 一个或多个 JavaBean 对象，用于存储数据（实体模型，由 JavaBean 类创建）和处理业务逻辑（业务模型，由一般的 Java 类创建）。 V：是指用户界面（jsp） 一个或多个&nbsp;JSP&nbsp;页面，向控制器提交数据和为模型提供数据显示，JSP 页面主要使用 HTML 标记和 JavaBean 标记来显示数据。 C：则是控制器（servlet） 一个或多个 Servlet 对象，根据视图提交的请求进行控制，即将请求转发给处理业务逻辑的 JavaBean，并将处理结果存放到实体模型 JavaBean 中，输出给视图显示。 MVVM是参考MVC而来的","categories":[{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"}]},{"title":"基于vue的音乐盒","slug":"13-基于vue的音乐盒","date":"2021-12-27T23:30:59.000Z","updated":"2022-01-26T14:31:08.363Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://zfengchen.github.io/posts/13.html","excerpt":"","text":"demo介绍：通过在输入框输入歌曲名称，点击搜索按钮后，通过Axios向后台发送Ajax请求，这个demo我使用的是qq音乐api接口，可以获取相关的歌曲信息，比如评论、歌曲url等。然后将相关信息渲染到相应的位置。 AxiosAxios官网 什么是 axios？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 代码：/* 1:歌曲搜索接口 请求地址:https://autumnfish.cn/search 请求方法:get 请求参数:keywords(查询关键字) 响应内容:歌曲搜索结果 2:歌曲url获取接口 请求地址:https://autumnfish.cn/song/url 请求方法:get 请求参数:id(歌曲id) 响应内容:歌曲url地址 3.歌曲详情获取 请求地址:https://autumnfish.cn/song/detail 请求方法:get 请求参数:ids(歌曲id) 响应内容:歌曲详情(包括封面信息) 4.热门评论获取 请求地址:https://autumnfish.cn/comment/hot?type=0 请求方法:get 请求参数:id(歌曲id,地址中的type固定为0) 响应内容:歌曲的热门评论 5.mv地址获取 请求地址:https://autumnfish.cn/mv/url 请求方法:get 请求参数:id(mvid,为0表示没有mv) 响应内容:mv的地址 */ new Vue({ el: '#player', data: { query: '', musicList: [], // 歌曲地址 musicUrl: \"\", // 封面地址 picUrl: '', // 热门评论 hotComments: [], isPlaying: false, // 遮罩层显示 isShow: false, // mv的地址 mvUrl : '' }, methods: { // 歌曲查询 result.data.songs searchMusic: function () { var that = this axios.get('https://autumnfish.cn/search?keywords=' + this.query).then(function (res) { console.log(res.data); that.musicList = res.data.result.songs; // console.log(that.musicList); }).catch(function (err) { console.log(err); }); }, // 音乐播放 playMusic: function (musicId) { // console.log(musicId); var that = this var mUrl = 'https://music.163.com/song/media/outer/url?id=' + musicId + '.mp3' that.musicUrl = mUrl // 歌曲封面 axios.get('https://api.imjad.cn/cloudmusic/?type=detail&amp;id=' + musicId).then(function (res) { // console.log(res.data.songs[0].al.picUrl); that.picUrl = res.data.songs[0].al.picUrl; }).catch(function (err) { console.log(err); }); // 热门评论获取 axios.get('https://autumnfish.cn/comment/hot?type=0&amp;id=' + musicId).then(function (res) { // console.log(res.data.hotComments); that.hotComments = res.data.hotComments; }).catch(function (err) { console.log(err); }); }, // 播放 play: function () { this.isPlaying = true }, // 暂停 pause: function () { this.isPlaying = false }, // 播放mv playMv: function (mvid) { var that = this axios.get('https://autumnfish.cn/mv/url?id=' + mvid).then(function (res) { console.log(res.data.data.url); that.isShow = true; that.mvUrl = res.data.data.url; }).catch(function (err) { }); }, // 隐藏遮罩层 hide : function () { this.isShow = false; this.mvUrl = '' } }, }) 效果：","categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://zfengchen.github.io/tags/Ajax/"},{"name":"Axios","slug":"Axios","permalink":"https://zfengchen.github.io/tags/Axios/"}]},{"title":"基于vue的天气预报","slug":"12-基于vue的天气预报","date":"2021-12-27T23:00:14.000Z","updated":"2022-01-26T14:31:07.396Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://zfengchen.github.io/posts/12.html","excerpt":"","text":"demo介绍：通过在输入框输入城市名称，点击搜索按钮后，通过Axios向后台发送Ajax请求，获取导数据后，将数据渲染到页面上。 AxiosAxios官网 什么是 axios？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 代码：/* 请求地址:http://wthrcdn.etouch.cn/weather_mini 请求方法:get 请求参数:city(城市名) 响应内容:天气信息 1. 点击回车 2. 查询数据 3. 渲染数据 */ new Vue({ el: '#app', data: { city: '', weatherList : [] }, methods: { searchWeather: function () { // console.log(this.city); var that = this axios.get('http://wthrcdn.etouch.cn/weather_mini?city=' + this.city).then(function (res) { // console.log(res.data.data.forecast); that.weatherList = res.data.data.forecast }).catch(function (err) { console.log(err); }); }, changeCity: function (city) { this.city = city this.searchWeather() } }, }) 效果：","categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://zfengchen.github.io/tags/Ajax/"},{"name":"Axios","slug":"Axios","permalink":"https://zfengchen.github.io/tags/Axios/"}]},{"title":"PC端网页特效","slug":"11-PC端网页特效","date":"2021-12-27T12:24:14.000Z","updated":"2021-12-27T14:32:24.064Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://zfengchen.github.io/posts/11.html","excerpt":"","text":"目录 元素偏移量 offset 系列 元素可视区 client 系列 元素滚动 scroll 系列 动画函数封装 常见网页特效案例 1. 元素偏移量 offset 系列 1.1 offset 概述 1.2 offset 与 style 区别 案例 获取鼠标在盒子内的坐标 var box = document.querySelector('.box'); box.addEventListener('mousemove', function(e) { var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; this.innerHTML = 'x坐标是' + x + ' y坐标是' + y; }) 模态框拖拽 // 1. 获取元素 var login = document.querySelector('.login'); var mask = document.querySelector('.login-bg'); var link = document.querySelector('#link'); var closeBtn = document.querySelector('#closeBtn'); var title = document.querySelector('#title'); // 2. 点击弹出层这个链接 link 让mask 和login 显示出来 link.addEventListener('click', function() { mask.style.display = 'block'; login.style.display = 'block'; }) // 3. 点击 closeBtn 就隐藏 mask 和 login closeBtn.addEventListener('click', function() { mask.style.display = 'none'; login.style.display = 'none'; }) // 4. 开始拖拽 // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标 title.addEventListener('mousedown', function(e) { var x = e.pageX - login.offsetLeft; var y = e.pageY - login.offsetTop; // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值 document.addEventListener('mousemove', move) function move(e) { login.style.left = e.pageX - x + 'px'; login.style.top = e.pageY - y + 'px'; } // (3) 鼠标弹起，就让鼠标移动事件移除 document.addEventListener('mouseup', function() { document.removeEventListener('mousemove', move); }) }) 仿京东放大镜 2. 元素可视区 client 系列 2.2 client 系列的相关属性 案例 淘宝 flexible.js 源码分析 仿淘宝固定右侧侧边栏 3. 元素滚动 scroll 系列 3.1 元素 scroll 系列属性 3.2 页面被卷去的头部 如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 3.3 页面被卷去的头部兼容性解决方案 案例 三大系列总结 三大系列区别 他们主要用法： offset系列 经常用于获得元素位置 offsetLeft offsetTop client 经常用于获取元素大小 clientWidth clientHeight scroll 经常用于获取滚动距离 scrollTop scrollLeft 注意页面滚动的距离通过 window.pageXOffset 获得","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://zfengchen.github.io/tags/Javascript/"}]},{"title":"事件高级","slug":"10-事件高级","date":"2021-12-27T12:23:45.000Z","updated":"2021-12-27T14:32:22.965Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://zfengchen.github.io/posts/10.html","excerpt":"","text":"1. 注册事件（绑定事件） 1.1 注册事件概述 1.2 addEventListener 事件监听方式（重点） 1.3 attachEvent 事件监听方式（了解） 1.4 注册事件兼容性解决方案（了解） 兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器 function addEventListener(element, eventName, fn) { // 判断当前浏览器是否支持 addEventListener 方法 if (element.addEventListener) { element.addEventListener(eventName, fn); // 第三个参数 默认是false } else if (element.attachEvent) { element.attachEvent('on' + eventName, fn); } else { // 相当于 element.onclick = fn; element['on' + eventName] = fn; } 2. 删除事件（解绑事件） 2.1 删除事件的方式 2.2 删除事件兼容性解决方案（了解） function removeEventListener(element, eventName, fn) { // 判断当前浏览器是否支持 removeEventListener 方法 if (element.removeEventListener) { element.removeEventListener(eventName, fn); // 第三个参数 默认是false } else if (element.detachEvent) { element.detachEvent('on' + eventName, fn); } else { element['on' + eventName] = null; } 3. DOM 事件流 DOM 事件流 4. 事件对象 4.1 什么是事件对象 4.2 事件对象的使用语法 4.3 事件对象的兼容性方案 4.4 事件对象的常见属性和方法 5. 阻止事件冒泡 5.1 阻止事件冒泡的两种方式 5.2 阻止事件冒泡的兼容性解决方案 if(e &amp;&amp; e.stopPropagation){ e.stopPropagation(); }else{ window.event.cancelBubble = true; } 6. 事件委托（代理、委派） 事件委托 案例 // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // alert('知否知否，点我应有弹框在手！'); // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = 'pink'; }) 7. 常用的鼠标事件 7.1 常用的鼠标事件 7.2 鼠标事件对象 8. 常用的键盘事件 8.1 常用键盘事件 8.2 键盘事件对象 8.3 ASCII 表","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://zfengchen.github.io/tags/Javascript/"}]},{"title":"DOM文档对象模型","slug":"09-DOM文档对象模型","date":"2021-12-27T12:23:05.000Z","updated":"2021-12-27T14:32:32.060Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://zfengchen.github.io/posts/9.html","excerpt":"","text":"1. DOM 简介 1.1 什么是 DOM 文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 1.2 DOM 树 2. 获取元素 2.1 如何获取页面元素 2.2 根据 ID 获取 document.getElementById(‘id’); 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。 2.3 根据标签名获取 document.getElementsByTagName(‘标签名’); 注：使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合 1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。 2.得到元素对象是动态的 2.4 通过 HTML5 新增的方法获取 2.5 获取特殊元素（body，html） 3. 事件基础 3.1 事件概述 3.2 事件三要素 事件源 （谁） 事件类型 （什么事件） 事件处理程序 （做啥） 3.3 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值形式） 3.3常见的鼠标事件 4. 操作元素 4.1 改变元素内容 常用的是element.innerHTML 4.2 常用元素的属性操作 4.3 表单元素的属性操作 4.4 样式属性操作 操作元素的方法 操作元素总结 4.5 排他思想 4.6 自定义属性的操作 4.7 H5自定义属性 案例 5. 节点操作 5.1 为什么学节点操作 5.2 节点概述 5.3 节点层级 父级节点 子节点 兄弟节点 5.4 创建、添加、删除、复制节点 创建节点 添加节点 删除节点 复制节点(克隆节点) 5.5 三种动态创建元素区别 案例 6. DOM 重点核心关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 6.1 创建 6.2 增 6.3 删 6.4 改 6.5 查 6.6 属性操作 6.7 事件操作","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://zfengchen.github.io/tags/Javascript/"}]},{"title":"BOM浏览器对象模型","slug":"08-BOM浏览器对象模型","date":"2021-12-27T12:21:53.000Z","updated":"2021-12-27T14:32:38.365Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://zfengchen.github.io/posts/8.html","excerpt":"","text":"BOM特性浏览器对象模型 把「浏览器」当做一个「对象」来看待 BOM 的顶级对象是 window BOM 学习的是浏览器窗口交互的一些对象 BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差 BOM构成 BOM的各类方法（重点） 定时器 setTimeout() window.setTimeout(调用函数, [延迟的毫秒数]); setTimeout() 这个调用函数我们也称为回调函数 callback 普通函数是按照代码顺序直接调用。 而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。 简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。 以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调 函数。 停止 setTimeout() 定时器 window.clearTimeout(timeoutID) //clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。 //注意： //1. window 可以省略。 //2. 里面的参数就是定时器的标识符 。 setInterval() window.setInterval(回调函数, [间隔的毫秒数]); setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 注意： window 可以省略。 这个调用函数可以直接写函数，或者写函数名或者采取字符串 ‘函数名()’ 三种形式。 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。 停止 setInterval() 定时器 window.clearInterval(intervalID); //clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。 //注意： //1. window 可以省略。 //2. 里面的参数就是定时器的标识符 。 setTimeout()和setInterval()的区别 setTimeout()只执行一次 setInterval()会重复执行 BOM重点案例 5秒后自动关闭的广告—setTimeout() var ad = document.querySelector('.ad');//ad为广告图片的类名 setTimeout(function() { ad.style.display = 'none'; }, 5000); 倒计时—setInterval() var hour = document.querySelector('.hour'); var minute = document.querySelector('.minute'); var second = document.querySelector('.second'); var inputTime = +new Date('2021-9-20 20:00:00');//最终时间 countDown(); setInterval(countDown, 1000); function countDown() { var nowTime = +new Date(); // 返回的是当前时间总的毫秒数 var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 var h = parseInt(times / 60 / 60 % 24); //时 h = h &lt; 10 ? '0' + h : h; hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子 var m = parseInt(times / 60 % 60); // 分 m = m &lt; 10 ? '0' + m : m; minute.innerHTML = m; var s = parseInt(times % 60); // 当前的秒 s = s &lt; 10 ? '0' + s : s; second.innerHTML = s; } 发送短信—setInterval() // 按钮点击之后，会禁用 disabled 为true // 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改 // 里面秒数是有变化的，因此需要用到定时器 // 定义一个变量，在定时器里面，不断递减 // 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态 var btn = document.querySelector('button'); var time = 3; // 定义剩下的秒数 btn.addEventListener('click', function() { btn.disabled = true; var timer = setInterval(function() { if (time == 0) { // 清除定时器和复原按钮 clearInterval(timer); btn.disabled = false; btn.innerHTML = '发送'; } else { btn.innerHTML = '还剩下' + time + '秒'; time--; } }, 1000); }) 电子时钟—setInterval() 5秒钟之后自动跳转页面—setInterval() var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.addEventListener('click', function() { // console.log(location.href); location.href = 'http://www.itcast.cn'; }) var timer = 5; setInterval(function() { if (timer == 0) { location.href = 'http://www.itcast.cn'; } else { div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页'; timer--; } }, 1000); 获取 URL 参数数据—location 对象 console.log(location.search); // ?uname=andy // 1.先去掉？ substr('起始的位置'，截取几个字符); 切片 var params = location.search.substr(1); // uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split('='); var arr = params.split('='); console.log(arr); // [\"uname\", \"ANDY\"] var div = document.querySelector('div'); // 3.把数据写入div中 div.innerHTML = arr[1] + '欢迎您'; JS执行机制同步和异步的概念： 同步 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 异步 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 他们的本质区别： 这条流水线上各个流程的执行顺序不同 location 对象概念： window 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。 URL location 对象的属性 location 对象的方法","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://zfengchen.github.io/tags/Javascript/"}]},{"title":"服务端渲染和客户端渲染","slug":"07-服务端渲染和客户端渲染","date":"2021-12-27T02:57:51.000Z","updated":"2021-12-27T14:32:43.220Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://zfengchen.github.io/posts/7.html","excerpt":"","text":"客户端渲染（Ajax）页面的局部刷新 优点 可以向用户快速展示页面的内容，增加用户体验 给别人爬虫爬取相应的内容增加一定的困难 缺点 可能需要向服务器请求多次数据 不利于SEO 搜索引擎优化，即百度、搜狗等搜索引擎搜索不到客户端渲染的数据 服务端渲染（NodeJs）整个页面的刷新 优点 可以向用户快速展示页面的内容，增加用户体验 给别人爬虫爬取相应的内容增加一定的困难 缺点 可能需要向服务器请求多次数据 不利于SEO 搜索引擎优化，即百度、搜狗等搜索引擎搜索不到客户端渲染的数据 区分客户端渲染和服务端渲染 网页源代码中没有动态数据的，是客户端渲染；（例子：京东的商品评论，局部刷新） 网页源代码中有数据的，是服务端渲染；（例子：京东商品分类，网址发生改变） 参考知乎文章：客户端渲染和服务器渲染的区别","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"NodeJs","slug":"06-NodeJs","date":"2021-12-27T02:43:53.000Z","updated":"2021-12-27T14:32:58.008Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://zfengchen.github.io/posts/6.html","excerpt":"","text":"关于nodejsNode.js 教程 如果你是一个前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那么Node.js是一个非常好的选择。 Node.js 是运行在服务端的 JavaScript，如果你熟悉Javascript，那么你将会很容易的学会Node.js。 当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。 Node介绍为什么要学习Node.js 企业需求 具有服务端开发经验更改 front-end back-end 全栈开发工程师 基本的网站开发能力 服务端 前端 运维部署 多人社区 Node.js是什么 Node.js是JavaScript 运行时 通俗易懂的讲，Node.js是JavaScript的运行平台 Node.js既不是语言，也不是框架，它是一个平台 浏览器中的JavaScript EcmaScript 基本语法 if var function Object Array Bom Dom Node.js中的JavaScript 没有Bom，Dom EcmaScript 在Node中这个JavaScript执行环境为JavaScript提供了一些服务器级别的API 例如文件的读写 网络服务的构建 网络通信 http服务器 构建与Chrome的V8引擎之上 代码只是具有特定格式的字符串 引擎可以认识它，帮你解析和执行 Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行时环境 Node.js uses an envent-driven,non-blocking I/O mode that makes it lightweight and efficent. envent-driven 事件驱动 non-blocking I/O mode 非阻塞I/O模型（异步） ightweight and efficent. 轻量和高效 Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world npm 是世界上最大的开源生态系统 绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用 npm install jquery Node能做什么 web服务器后台 命令行工具 npm(node) git(c语言) hexo（node） … 对于前端工程师来讲，接触最多的是它的命令行工具 自己写的很少，主要是用别人第三方的 webpack gulp npm 参考：李鹏周老师的笔记","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zfengchen.github.io/tags/nodejs/"}]},{"title":"解决art-Template前后端语法冲突问题","slug":"05-关于artTenplate前后端语法冲突问题","date":"2021-12-25T07:21:50.000Z","updated":"2021-12-25T08:00:29.275Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://zfengchen.github.io/posts/5.html","excerpt":"","text":"前言：art-template 是一个简约、超快的模板引擎。它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。 art-Template官网文档 模板语法： 问题：ajax请求后获取到后台传来的数据，在使用模板引擎渲染到页面上。但是渲染出来的是空白数据，没有报错，起初以为是template-web.js的引入有问题。⚠️ 在 art-template 的使用中，它存在前后端冲突的问题，所以它只会接受服务端传过来的数据 解决方案： 找到项目中 node_module 下的 art-template 中的 lib /compile 下的 default.js 文件目录结构如图所示 其中，将 rules: [navtiveRule, artRule] 中的 navtiveRule 删除 之后服务端只能解析 被 { { } } 包起来的内容，而浏览器端只能使用 &lt;%= %&gt; 语法进行编译 详见大佬解释nodejs中art-template模板语法冲突解决方案_坤小的专栏-CSDN博客","categories":[{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"artTemplate","slug":"artTemplate","permalink":"https://zfengchen.github.io/tags/artTemplate/"}]},{"title":"使用vscode将项目发布到github上","slug":"04-关于vscode将项目发布到github上","date":"2021-12-25T06:55:28.000Z","updated":"2021-12-25T07:55:15.409Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://zfengchen.github.io/posts/4.html","excerpt":"","text":"先初始化存储库 提交更改会显示要username和email 控制台输入 git config user.name 'github的用户名' git config user.email 'github的邮箱' 在github上创建新的库点击左上角的三个点，推送 选择新创建的库 中途可能会网路不稳定，多试几次 成功后点击以下按钮，也要多试几次 然后就成功。 旧项目添加新分支推送把项目克隆到本地，把新的文件覆盖旧的文件，然后创建新的分支，再提交。","categories":[{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"github","slug":"github","permalink":"https://zfengchen.github.io/tags/github/"}]},{"title":"关于个人图床问题","slug":"02-关于个人图床问题","date":"2021-12-23T01:50:23.000Z","updated":"2021-12-25T06:57:11.025Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://zfengchen.github.io/posts/2.html","excerpt":"","text":"在网上看到的搭建图床的教程或者使用免费的图床网站。 免费的图床网站 免费的图床网站主要有七牛云、路过图床、聚合图床、公益图床等。 路过图床 路过图床注意有一些注意事项，如果出现违规的图片就会封IP，不给上传新的图片。公益图床 公益图床因为没有用户系统，所以不能管理已上传的图片，也就是说每次上传完之后都要备份好上传后的域名，十分麻烦。 自己搭建图床 一般使用github或者gitee来搭建 使用github搭建 搭建前需要准备一个github账号，下载一个PicGo的软件。 PpicGo设置如下 仓库名是github新建的一个仓库，具体操作自行百度 分支名是仓库的分支 Token是密钥，这个也自行百度 指定存储路径是仓库里的文件夹路径，不设置的话默认放在仓库的根目录下，如需设置，格式为**xxx/**（例如：img/）。 自定义域名是设置图片上传成功后，能直接访问的域名。格式一般为：**https://xxx.com/**","categories":[{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"capstone实作","slug":"03-capstone实作","date":"2021-12-22T05:28:53.000Z","updated":"2022-01-28T07:16:13.854Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://zfengchen.github.io/posts/3.html","excerpt":"","text":"基于nodejs的响应式校园订餐系统项目需求：校园点餐系统 项目运行展示首页，自动查询目前未使用的餐桌 首页需求 可根据餐桌名称和餐桌的使用状态查找餐桌 点击餐桌名称，进入菜单页面占位——加入商品到购物车——下单 菜单页功能 占位——改变餐桌状态为正在使用，记录开始使用的时间 取消占位——改变餐桌状态为未使用 购物车——加入商品到购物车，购物车商品数量修改及删除 下单——删除当前餐桌中购物车中商品，保存订单信息到数据库 付款——下单后可取消订单或付款，同时餐桌的状态改为未使用 登录和注册 filter / cookies 登录拦截器——要求3内的功能都需登录才可操作 记住密码 cookie。 注册： 帐号 姓名 密码 地址 手机 登录： 帐号 密码 github地址https://github.com/zfengChen/OrderSystem.git","categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zfengchen.github.io/tags/nodejs/"},{"name":"mongodb","slug":"mongodb","permalink":"https://zfengchen.github.io/tags/mongodb/"}]},{"title":"第一篇博文","slug":"01-博客诞生","date":"2021-12-22T05:13:52.000Z","updated":"2022-01-26T14:28:53.050Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://zfengchen.github.io/posts/1.html","excerpt":"","text":"我欲乘风归去，又恐琼楼玉宇，高处不胜寒。 技术栈使用hexo搭配nodejs搭建一个个人博客，主题使用的是Butterfly，经过某位大佬改装。 博客的挂载个人博客挂载在github上 文章语法使用Markdown语法 图片 音乐","categories":[{"name":"生活","slug":"生活","permalink":"https://zfengchen.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://zfengchen.github.io/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"项目","slug":"项目","permalink":"https://zfengchen.github.io/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"笔记","slug":"笔记","permalink":"https://zfengchen.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"学习","slug":"学习","permalink":"https://zfengchen.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"https://zfengchen.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zfengchen.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"Vue","permalink":"https://zfengchen.github.io/tags/Vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://zfengchen.github.io/tags/Ajax/"},{"name":"Axios","slug":"Axios","permalink":"https://zfengchen.github.io/tags/Axios/"},{"name":"Vant","slug":"Vant","permalink":"https://zfengchen.github.io/tags/Vant/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"https://zfengchen.github.io/tags/Vue-Router/"},{"name":"Echarts","slug":"Echarts","permalink":"https://zfengchen.github.io/tags/Echarts/"},{"name":"Swiper","slug":"Swiper","permalink":"https://zfengchen.github.io/tags/Swiper/"},{"name":"Valine","slug":"Valine","permalink":"https://zfengchen.github.io/tags/Valine/"},{"name":"Leancloud","slug":"Leancloud","permalink":"https://zfengchen.github.io/tags/Leancloud/"},{"name":"this","slug":"this","permalink":"https://zfengchen.github.io/tags/this/"},{"name":"面试高频题","slug":"面试高频题","permalink":"https://zfengchen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"},{"name":"git","slug":"git","permalink":"https://zfengchen.github.io/tags/git/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zfengchen.github.io/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"https://zfengchen.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://zfengchen.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"博客","slug":"博客","permalink":"https://zfengchen.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://zfengchen.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"Javascript","permalink":"https://zfengchen.github.io/tags/Javascript/"},{"name":"artTemplate","slug":"artTemplate","permalink":"https://zfengchen.github.io/tags/artTemplate/"},{"name":"github","slug":"github","permalink":"https://zfengchen.github.io/tags/github/"},{"name":"mongodb","slug":"mongodb","permalink":"https://zfengchen.github.io/tags/mongodb/"},{"name":"想法","slug":"想法","permalink":"https://zfengchen.github.io/tags/%E6%83%B3%E6%B3%95/"}]}